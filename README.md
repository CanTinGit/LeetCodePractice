# LeetCode Note
7\. Reverse Integer：对于检测最大值，没有合适把握，无法选择正确的格式对值进行存储，导致丢失部分数据。同时老是用/10导致无法确定上界，消耗了时间去计算。改为用%10从下往上可以极大节省时间。

9\. Palindrome Number:我的思路是直接利用取余法求得倒过来的数然后与原数据进行比较，直接但效率不高，从其他人那看到的思路，其实可以只求一半倒数然后与另一半作比较，既方便又快捷。

13\. Roman to Integer：这道题没有思路，翻阅讨论区发现原来IV其实就是V-I其余类似，都是前一个减去后一个。


26\. Remove Duplicates from sorted array：要得到时间复杂度最低的解，并不需要每次找到重复就移除，因为已经是有序数组，可以从0开始遍历，依次保留0,1,2........检测到重复的值，直接移动至末尾，最后一次全部移除（resize）即可。

35\. Binary search: 改变max和min的值的时候要多一位，即min=mid+1，max=mid-1，这样才能保证遍历完整个数组。用while循环更方便

53\. Maximum Subarray: 每次遍历，用当前和加上当前数组的值，然后与目前最大值比较，如果大于最大值，则更新最大值为和，否则不更新，然后与0比较，若大于0则保留当前和否则设当前和为0。这样只需一次遍历即可。（即永远比较当前数组值和它下一位加起来之和是否大于原值，若大于则更新最大值否则后移，同时比较目前的加和是否大于0，若大于则还可以往后加，若已经不大于0，则意味后面的值带来的是当前最大值的减少，就一定不可能是最后想要的最大值）

88\. Merge Sorted Array: 虽然做出来的，但是时间复杂度很高，用的是二分查找找到合适位置再插入。实际可采用升序排序思想从后往前依次排，这样只需遍历一次（m+n）即可。
